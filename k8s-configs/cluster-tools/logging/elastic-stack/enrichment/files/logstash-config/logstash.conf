input {
    http {
        id => "enrichment_in"
        port => 20510
        codec => "json"
        response_code => 200
        add_field => {"log_type" => "Enrichment_System_Log"}
    }
    tcp {
        id => "pf_provision_in"
        port => 20512
        add_field => {"log_type" => "PF_Provisioner_Log"}
    }
    tcp {
        id => "pf_system_in"
        port => 20513
        add_field => {"log_type" => "PF_System_Log"}
    }
    tcp {
        id => "pf_audit_in"
        port => 20514
        add_field => {"log_type" => "PF_Audit_Log"}
    }
    file {
        id => "var_log"
        path => "/var/log"
    }
    file {
        id => "containers_log"
        path => "/var/lib/docker/containers"
    }
}
filter {
    #PROCESS PING FED AUDIT LOG
    #Log4J Pattern Matching from PF and extraction of JSON DATA from the MSG
    if([log_type] == "PF_Audit_Log"){
        grok { 
            match => { 
                "message" => [ 
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG} , %{GREEDYDATA:json_data}",
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG}%{SPACE}%{GREEDYDATA:json_data}"
                    ]
            }
        } 
        #Convert the injested data into Individual Fields for elasticsearch
        json {
            source => "json_data"
        }

        if([json_data]){
            #Drop the original as you do not need it at this point.
            mutate {
                remove_field => "[json_data]"
            }

            geoip {
                source => "ip"
            }

            #Security Enrichments begin here, ENRICH THE IP ADDRESS DETAIL

            translate {
                field => "ip"
                destination => "threat_intel"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/AlienVaultIP.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "ip"
                destination => "tor_intel"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/TorNodes.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "[geoip][country_name]"
                destination => "malicious_country"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/MaliciousCountries.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "[geoip][country_name]"
                destination => "known_country"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/KnownCountries.yml'
                refresh_behaviour => "replace"
            }

            if([malicious_country] == "No" and [known_country] == "No"){
                mutate {
                    add_field => { "suspicious_country" => "YES" }
                }
            }

            # HERE SHOULD BE ADDITIONAL FILTERS WHICH RELATED TO PDO-966 SETTING UP LOGSTASH FILTERS SCOPE
        }
    }

    # PROCESS PING FED SYSTEM LOG
    # USING LOG4J's ability to output in JSON limits the amount of processing you have to do besides splitting up JSON.

    if([log_type] == "PF_System_Log"){
        grok { 
            match => { 
                "message" => [ 
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG} , %{GREEDYDATA:json_data}",
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG}%{SPACE}%{GREEDYDATA:json_data}"
                    ]
            }
        } 
        json {
            source => "json_data"
        }

        if([json_data]){
            mutate {
                remove_field => "[json_data]"
            }
        }   
    }
    # ruby {
    #     code => "
    #         require 'base64';
    #         event.set("USER", Base64.decode64(${ELASTIC_USER})
    #         event.set("PASSWORD", Base64.decode64(${ELASTIC_PASSWORD})
    #     "
    # }
    ruby { code => 'event.set("elastic_user", Base64.decode64(ENV["ELASTIC_USER"]))' }
    ruby { code => 'event.set("elastic_password", Base64.decode64(ENV["ELASTIC_USER"]))' }
    # exec {
    #     command => "export ELASTIC_USER_DECODED=$(echo $ELASTIC_USER | base64 -d) && export ELASTIC_PASSWORD_DECODED=$(echo $ELASTIC_PASSWORD | base64 -d)"
    # }
}
output {
    elasticsearch {
        #index => "logstash_%{+YYYY.MM.dd}"
        # hosts => "${LOGSTASH_ELASTICSEARCH_SCHEME}://${LOGSTASH_ELASTICSEARCH_HOST}:${LOGSTASH_ELASTICSEARCH_PORT}"
        # sniffing => false
        ssl => true
        ssl_certificate_verification => true
        cacert => "${CERTS_DIR}/ca/ca.crt"
        hosts => ["${XPACK_MONITORING_ELASTICSEARCH_HOSTS}"]
        ilm_enabled => true
        ilm_rollover_alias => "pd-access"
        ilm_policy => "ping-2-day-retention"
        user => "elastic"
        password => "3L@571C"
        # user => "%{[elastic_user]}"
        # password => "%{[elastic_password]}"
        # user => "${ELASTIC_USER_DECODED}"
        # password => "${ELASTIC_PASSWORD_DECODED}"
    }
    # if([log_type] == "Enrichment_System_Log"){
    #     elasticsearch {
    #         id => "enrichment_out"
    #         index => "enrichment_out_%{+YYYY.MM.dd}"
    #         hosts => "${LOGSTASH_ELASTICSEARCH_SCHEME}://${LOGSTASH_ELASTICSEARCH_HOST}:${LOGSTASH_ELASTICSEARCH_PORT}"
    #     }
    # }
    # if([log_type] == "PF_Provisioner_Log"){
    #     elasticsearch {
    #         id => "pf_provision_out"
    #         index => "pf_provision_out_%{+YYYY.MM.dd}"
    #         hosts => "${LOGSTASH_ELASTICSEARCH_SCHEME}://${LOGSTASH_ELASTICSEARCH_HOST}:${LOGSTASH_ELASTICSEARCH_PORT}"
    #     }
    # }
    # if([log_type] == "PF_Audit_Log"){
    #     elasticsearch {
    #         id => "pf_audit_out"
    #         index => "pf_audit_out_%{+YYYY.MM.dd}"
    #         hosts => "${LOGSTASH_ELASTICSEARCH_SCHEME}://${LOGSTASH_ELASTICSEARCH_HOST}:${LOGSTASH_ELASTICSEARCH_PORT}"
    #     }
    # }
    # if([log_type] == "PF_System_Log"){
    #     elasticsearch {
    #         id => "pf_system_out"
    #         index => "pf_system_out_%{+YYYY.MM.dd}"
    #         hosts => "${LOGSTASH_ELASTICSEARCH_SCHEME}://${LOGSTASH_ELASTICSEARCH_HOST}:${LOGSTASH_ELASTICSEARCH_PORT}"
    #     }
    # }
}