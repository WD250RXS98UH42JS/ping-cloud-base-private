input {
    http {
        id => "enrichment_in"
        port => 20510
        codec => "json"
        response_code => 200
        add_field => {"log_type" => "Enrichment_System_Log"}
    }
    tcp {
        id => "pf_provision_in"
        port => 20512
        add_field => {"log_type" => "PF_Provisioner_Log"}
    }
    tcp {
        id => "pf_system_in"
        port => 20513
        add_field => {"log_type" => "PF_System_Log"}
    }
    tcp {
        id => "pf_audit_in"
        port => 20514
        add_field => {"log_type" => "PF_Audit_Log"}
    }
    file {
        id => "var_log"
        path => "/var/log"
    }
    file {
        id => "containers_log"
        path => "/var/lib/docker/containers"
    }
}
filter {
    #PROCESS PING FED AUDIT LOG
    #Log4J Pattern Matching from PF and extraction of JSON DATA from the MSG
    if([log_type] == "PF_Audit_Log"){
        grok { 
            match => { 
                "message" => [ 
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG} , %{GREEDYDATA:json_data}",
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG}%{SPACE}%{GREEDYDATA:json_data}"
                    ]
            }
        } 
        #Convert the injested data into Individual Fields for elasticsearch
        json {
            source => "json_data"
        }

        if([json_data]){
            #Drop the original as you do not need it at this point.
            mutate {
                remove_field => "[json_data]"
            }

            geoip {
                source => "ip"
            }

            #Security Enrichments begin here, ENRICH THE IP ADDRESS DETAIL

            translate {
                field => "ip"
                destination => "threat_intel"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/AlienVaultIP.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "ip"
                destination => "tor_intel"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/TorNodes.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "[geoip][country_name]"
                destination => "malicious_country"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/MaliciousCountries.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "[geoip][country_name]"
                destination => "known_country"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/KnownCountries.yml'
                refresh_behaviour => "replace"
            }

            if([malicious_country] == "No" and [known_country] == "No"){
                mutate {
                    add_field => { "suspicious_country" => "YES" }
                }
            }

            #Query for previous logins in Elasticsearch, if login is found append data to the log
            #IF A SUCCESSFUL LOGIN OCCURS, Query ES to see if the the attempt was successful in the past to determine distance from previous login.

            if([status] == "success" and [event] == "AUTHN_ATTEMPT"){
                elasticsearch {
                    index => "pf-audit*"
                    query_template => "/etc/logstash/templates/6hr-1200km-template.json"
                    hosts => "${LOGSTASH_ELASTICSEARCH_URL}:${LOGSTASH_ELASTICSEARCH_PORT}"

                    add_field => {"found_distance_alert" => "YES"}

                    fields => {
                        "subject" => "found_subject"
                        "ip" => "found_ip"
                        "[geoip][country_name]" => "found_country"
                        "[geoip][city_name]" => "found_city_name"
                        "[geoip][location][lat]" => "[found_geoip][location][lat]"
                        "[geoip][location][lon]" => "[found_geoip][location][lon]"
                    }
                }
            }


        }
    }

    # PROCESS PING FED SYSTEM LOG
    # USING LOG4J's ability to output in JSON limits the amount of processing you have to do besides splitting up JSON.

    if([log_type] == "PF_System_Log"){
        grok { 
            match => { 
                "message" => [ 
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG} , %{GREEDYDATA:json_data}",
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG}%{SPACE}%{GREEDYDATA:json_data}"
                    ]
            }
        } 
        json {
            source => "json_data"
        }

        if([json_data]){
            mutate {
                remove_field => "[json_data]"
            }
        }   
    }

    # PROCESS PING DIRECTORY LOGS
    # LOGS ARE SENT IN A CUSTOM FORMAT, AND THIS CONFIG MATCHES AND PARSES THEM.

    if([log_type] == "PD_Access_Log"){
        kv {
            source => "[message]"
            value_split => "="
        }

        grok {
            match => { "message" => "\A%{WORD:ldapType} %{GREEDYDATA}" }
        }

        mutate{
            gsub => [ 
                "filter", '"', ""
            ]
            gsub => [ 
                "dn", '"', ""
            ]
        }

        geoip {
            source => "requesterIP"
        }

        translate {
            field => "requesterIP"
            destination => "threat_intel"
            fallback => "No"
            dictionary_path => '/enrichment-shared-volume/enrichment-cache/AlienVaultIP.yml'
            refresh_behaviour => "replace"
        }

        translate {
            field => "requesterIP"
            destination => "tor_intel"
            fallback => "No"
            dictionary_path => '/enrichment-shared-volume/enrichment-cache/TorNodes.yml'
            refresh_behaviour => "replace"
        }

        translate {
            field => "[geoip][country_name]"
            destination => "malicious_country"
            fallback => "No"
            dictionary_path => '/enrichment-shared-volume/enrichment-cache/MaliciousCountries.yml'
            refresh_behaviour => "replace"
        }

        translate {
            field => "[geoip][country_name]"
            destination => "known_country"
            fallback => "No"
            dictionary_path => '/enrichment-shared-volume/enrichment-cache/KnownCountries.yml'
            refresh_behaviour => "replace"
        }

        if([malicious_country] == "No" and [known_country] == "No"){
            mutate {
                add_field => { "suspicious_country" => "YES" }
            }
        }

        mutate {
            remove_field => "[message]"
            remove_field => "[tags]"
        }
    }

    # PROCESS PING ACCESS AUDIT LOG
    # PING ACCESS IS SENDING IN LOG4J FORMAT (JSON), SO PARSING IS MUCH LIKE PING FED.

    if([log_type] == "PA_Audit_Log"){
        grok { 
            match => { 
                "message" => [ 
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG} , %{GREEDYDATA:json_data}",
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG}%{SPACE}%{GREEDYDATA:json_data}"
                    ]
            }
        } 
        json {
            source => "json_data"
        }

        if([json_data]){
            mutate {
                remove_field => "[json_data]"
            }
            geoip {
                source => "client"
            }

            translate {
                field => "client"
                destination => "threat_intel"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/AlienVaultIP.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "client"
                destination => "tor_intel"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/TorNodes.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "[geoip][country_name]"
                destination => "malicious_country"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/MaliciousCountries.yml'
                refresh_behaviour => "replace"
            }

            translate {
                field => "[geoip][country_name]"
                destination => "known_country"
                fallback => "No"
                dictionary_path => '/enrichment-shared-volume/enrichment-cache/KnownCountries.yml'
                refresh_behaviour => "replace"
            }

            if([malicious_country] == "No" and [known_country] == "No"){
                mutate {
                    add_field => { "suspicious_country" => "YES" }
                }
            }
        }
    }

    if([log_type] == "PA_System_Log"){
        grok { 
            match => { 
                "message" => [ 
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG} , %{GREEDYDATA:json_data}",
                    "\A%{SYSLOG5424PRI}%{SYSLOGTIMESTAMP:event_timestamp}%{SPACE}%{SYSLOGPROG}%{SPACE}%{GREEDYDATA:json_data}"
                    ]
            }
        } 
        json {
            source => "json_data"
        }
    }

    if([log_type] == "Enrichment_System_Log"){
        mutate {
            remove_field => [ "json", "[headers]" ]
        }
    }
}

output {
    elasticsearch {
        index => "logstash_%{+YYYY.MM.dd}"
        hosts => "${LOGSTASH_ELASTICSEARCH_URL}:${LOGSTASH_ELASTICSEARCH_PORT}"
        sniffing => false
        ilm_enabled => true
        ilm_rollover_alias => "logstash"
        ilm_policy => "ping-2-day-retention"
    }
    if([log_type] == "Enrichment_System_Log"){
        elasticsearch {
            id => "enrichment_out"
            # index => "enrichment_out_%{+YYYY.MM.dd}"
            hosts => "${LOGSTASH_ELASTICSEARCH_URL}:${LOGSTASH_ELASTICSEARCH_PORT}"
            ilm_enabled => true
            ilm_rollover_alias => "enrichment"
            ilm_policy => "ping-2-day-retention"
        }
    }
    if([log_type] == "PF_Provisioner_Log"){
        elasticsearch {
            id => "pf_provision_out"
            # index => "pf_provision_out_%{+YYYY.MM.dd}"
            hosts => "${LOGSTASH_ELASTICSEARCH_URL}:${LOGSTASH_ELASTICSEARCH_PORT}"
            ilm_enabled => true
            ilm_rollover_alias => "pf-provision"
            ilm_policy => "ping-2-day-retention"
        }
    }
    if([log_type] == "PF_Audit_Log"){
        elasticsearch {
            id => "pf_audit_out"
            # index => "pf_audit_out_%{+YYYY.MM.dd}"
            hosts => "${LOGSTASH_ELASTICSEARCH_URL}:${LOGSTASH_ELASTICSEARCH_PORT}"
            ilm_enabled => true
            ilm_rollover_alias => "pf-audit"
            ilm_policy => "ping-2-day-retention"
        }
    }
    if([log_type] == "PF_System_Log"){
        elasticsearch {
            id => "pf_system_out"
            # index => "pf_system_out_%{+YYYY.MM.dd}"
            hosts => "${LOGSTASH_ELASTICSEARCH_URL}:${LOGSTASH_ELASTICSEARCH_PORT}"
            ilm_enabled => true
            ilm_rollover_alias => "pf-system"
            ilm_policy => "ping-2-day-retention"
        }
    }
}